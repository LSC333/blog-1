2020-02-06 10:44:55.201  INFO 4940 --- [restartedMain] com.lhy.blog.BlogApplication             : Starting BlogApplication on DESKTOP-KCJEFBA with PID 4940 (E:\CODE\Java\blog\target\classes started by 16177 in E:\CODE\Java\blog)
2020-02-06 10:44:55.207 DEBUG 4940 --- [restartedMain] com.lhy.blog.BlogApplication             : Running with Spring Boot v2.2.4.RELEASE, Spring v5.2.3.RELEASE
2020-02-06 10:44:55.207  INFO 4940 --- [restartedMain] com.lhy.blog.BlogApplication             : The following profiles are active: dev
2020-02-06 10:44:55.299  INFO 4940 --- [restartedMain] o.s.b.devtools.restart.ChangeableUrls    : The Class-Path manifest attribute in C:\Users\16177\.m2\repository\org\glassfish\jaxb\jaxb-runtime\2.3.2\jaxb-runtime-2.3.2.jar referenced one or more files that do not exist: file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/jakarta.xml.bind-api-2.3.2.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/txw2-2.3.2.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/istack-commons-runtime-3.0.8.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/stax-ex-1.8.1.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/FastInfoset-1.2.16.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/jakarta.activation-api-1.2.1.jar
2020-02-06 10:44:55.300  INFO 4940 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-02-06 10:44:55.300  INFO 4940 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-02-06 10:44:56.741  INFO 4940 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2020-02-06 10:44:56.932  INFO 4940 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 163ms. Found 5 JPA repository interfaces.
2020-02-06 10:44:57.572  INFO 4940 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-02-06 10:44:58.620  INFO 4940 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2020-02-06 10:44:58.647  INFO 4940 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-06 10:44:58.648  INFO 4940 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.30]
2020-02-06 10:44:58.802  INFO 4940 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-06 10:44:58.802  INFO 4940 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 3502 ms
2020-02-06 10:44:59.302  INFO 4940 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2020-02-06 10:44:59.485  INFO 4940 --- [restartedMain] org.hibernate.Version                    : HHH000412: Hibernate Core {5.4.10.Final}
2020-02-06 10:44:59.794  INFO 4940 --- [restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.0.Final}
2020-02-06 10:44:59.964  INFO 4940 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-02-06 10:45:00.166  INFO 4940 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-02-06 10:45:00.202  INFO 4940 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL57Dialect
2020-02-06 10:45:01.568  INFO 4940 --- [restartedMain] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2020-02-06 10:45:01.577  INFO 4940 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-06 10:45:01.681  INFO 4940 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-06 10:45:02.914  WARN 4940 --- [restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2020-02-06 10:45:03.239  INFO 4940 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-02-06 10:45:03.386  INFO 4940 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-02-06 10:45:04.376  INFO 4940 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2020-02-06 10:45:04.379  INFO 4940 --- [restartedMain] com.lhy.blog.BlogApplication             : Started BlogApplication in 10.198 seconds (JVM running for 12.846)
2020-02-06 10:58:59.960  INFO 4940 --- [http-nio-8080-exec-3] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-02-06 10:58:59.961  INFO 4940 --- [http-nio-8080-exec-3] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-02-06 10:58:59.992  INFO 4940 --- [http-nio-8080-exec-3] o.s.web.servlet.DispatcherServlet        : Completed initialization in 31 ms
2020-02-06 10:59:00.056  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 10:59:00.059  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 10:59:00.060  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 10:59:00.060  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 10:59:00.105  WARN 4940 --- [http-nio-8080-exec-2] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-02-06 10:59:00.106  WARN 4940 --- [http-nio-8080-exec-1] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-02-06 10:59:00.273  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 10:59:00.292  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 10:59:00.278  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 10:59:00.297  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:00:24.427  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:00:24.430  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:00:24.436  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:00:24.444  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:00:24.449  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:00:24.480  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:00:24.481  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:00:24.499  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:00:45.186  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:00:45.188  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:00:45.194  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:00:45.203  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:00:45.213  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:00:45.220  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:00:45.227  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:00:45.232  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:00:47.121  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:00:47.125  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:00:47.142  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:00:47.148  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:00:47.151  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:00:47.155  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:00:47.160  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:00:47.176  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:04:17.674  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:04:17.674  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:04:17.691  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:04:17.697  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:04:17.713  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:04:17.720  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:04:17.729  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:04:17.738  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:19:00.149  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:19:00.149  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:19:00.151  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:19:00.154  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:19:00.172  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:19:00.177  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:19:00.186  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:19:00.190  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:25:44.578  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:25:44.584  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:25:44.602  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:25:44.607  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:25:44.629  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:25:44.611  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:25:44.633  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:25:44.650  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:38:48.880  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:38:48.884  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:38:48.888  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:38:48.895  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:38:48.899  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:38:48.912  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:38:48.923  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:38:48.944  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:39:34.206  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:39:34.209  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:39:34.219  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:39:34.227  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:39:34.234  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:39:34.240  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:39:34.246  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:39:34.255  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:40:50.115  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:40:50.116  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:40:50.120  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:40:50.134  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:40:50.135  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:40:50.139  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:40:50.147  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:40:50.157  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:42:34.871  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:42:34.871  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:42:34.874  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:42:34.888  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:42:34.893  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:42:34.900  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:42:34.904  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:42:34.908  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:53:56.494  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:53:56.494  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:53:56.496  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:53:56.500  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:53:56.510  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:53:56.523  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:53:56.523  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:53:56.538  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:54:49.938  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:54:49.941  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:54:49.944  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:54:49.951  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:54:49.958  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:54:49.963  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:54:49.968  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:54:49.974  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:58:04.814  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:58:04.815  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:58:04.818  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:58:04.824  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:58:04.827  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:58:04.828  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:58:04.853  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:58:04.867  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 11:59:24.968  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 11:59:24.970  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 11:59:24.972  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 11:59:24.983  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 11:59:24.983  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 11:59:24.990  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 11:59:24.994  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 11:59:25.004  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 12:11:06.886  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 12:11:06.886  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 12:11:06.888  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 12:11:06.902  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 12:11:06.902  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 12:11:06.909  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 12:11:06.915  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 12:11:06.927  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 12:15:05.179  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 12:15:05.180  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 12:15:05.181  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 12:15:05.188  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 12:15:05.195  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 12:15:05.201  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 12:15:05.207  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 12:15:05.214  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 12:16:02.603  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 12:16:02.621  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 12:16:02.631  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 12:16:02.631  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 12:16:02.631  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 12:16:02.637  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 12:16:02.639  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 12:16:02.655  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:22:46.330  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/132', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[132]}
2020-02-06 13:22:46.359  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=132, title='123', content='123', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}
2020-02-06 13:22:53.147  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:22:53.156  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:22:55.465  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:22:55.469  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:23:14.065  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:23:14.073  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:24:01.013  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/67', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[67]}
2020-02-06 13:24:01.017  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=67, title='表达式求值', content='表达式求值是程序设计编译中的一个最基本的问题，他的实现是栈应用的一个典型范例：

表达式中包含的运算符有`（，），+，-，*，/`，共七种运算符，我们首先要确定这七种运算符的优先级，显然`()`的优先级最高，`*,/`次之，`+,-`的优先级最低，那么`(`与`)`、`+`与`+`、`-`与`-`$$\cdots$$，这些优先级又怎么区分呢？我么用栈求表达式值时是将运算符存在栈中，例如当前栈中有`+`，当再来`+,-`时，显然栈中的`+`可以出栈了，那么栈中`+`的优先级就高于栈外的`+,-`，因此优先级相同的运算符在栈内的优先级应该高于栈外的优先级。下面以表格的形式给出各运算符的优先级：

| 操作符 | # | ( | *,/| +,- | ) |
| :-: | :-: | :-: | :-: | :-: | :-: |
| isp | 0 | 1 | 5 | 3 | 6 |
| icp | 0 | 6 | 4 | 2 | 1 |


其中引入`#`是为了统一运算。
对应的计算优先级的函数如下：

```cpp
int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}
```
这里介绍两种表达式求值的思路：
###### 1. 直接求值法
直接法顾名思义就是直接计算，不需要事先处理表达式；该方法需要两个栈，栈`nsta`存数字，栈`osta`存运算符，一次遍历表达式字符串，这会出现一下几种操作：
1. 当前字符是数字时，直接压入`nsta`；
2. 当前字符是运算符时:
	1. `isp(osta.top) < icp(ch)`，`ch`直接入栈；
	2. `isp(osta.top) > icp(ch)`，`osta.top`出栈，运算结果压入`nsta`，重复步骤1；
	3. `isp(osta.top) == icp(ch)`，只有两种可能，`isp('(') == icp(')')`，`isp('#') == icp('#')`，第一种情况左括号出栈，第二种情况表达式计算结束。

对应直接的直接发代码如下：

```cpp
void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;	//注意顺序
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;	//继续比较osta中的下一个运算符
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());	//nsta中只有一个元素，即为最终结果
}
```
###### 2. 后缀表达式求值
我们的表达式其实是中缀表达式，若将中缀表达式转化为后缀表达式，则只需直接计算即可，不需要考虑优先级的问题，因此将中缀表达式转化为后缀表达式的过程就是按优先级排列运算符，
其中将中缀表达式转化为后缀表达式的代码如下：

```cpp
queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}
```

 这里将后缀表达式存在队列中，同样也可以存在数组中，最后直接计算的代码如下：
 

```cpp
void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

```
最终完整的代码如下：

```cpp
#include <stdio.h>
#include <iostream>
#include <stack>
#include <queue>
#include <cstring>
using namespace std;

int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}

queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}

void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());
}
//  a+b-a*((c+d)/e-f)+g
int main(){
    char str[100];
    queue<char> que;
    scanf("%s", str);
    // 转化为后缀表达式，再通过后缀表达式计算结果
//    que = getSuffix(str);
//    calcSuffix(que);
    // 直接计算
    directCalc(str);
    return 0;
}

```
', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}
2020-02-06 13:24:10.007  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:24:10.015  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:24:12.048  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 13:24:12.052  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 13:24:16.133  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:24:16.147  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:25:35.672  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:25:35.672  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:25:35.677  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:25:35.678  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:25:35.690  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:25:35.691  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:25:35.692  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:25:35.699  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:26:12.896  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:26:12.898  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:26:12.905  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:26:12.912  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:26:12.921  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:26:12.925  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:26:12.936  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:26:12.946  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:26:23.609  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 13:26:23.613  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 13:26:44.902  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:26:44.910  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:27:28.638  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:27:28.643  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:30:17.759  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:30:17.763  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:32:17.722 ERROR 4940 --- [http-nio-8080-exec-10] c.l.b.h.ControllerExceptionHandler       : Request URL : http://localhost:8080/blog/undefined, Exception : {}

org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.lang.Long'; nested exception is java.lang.NumberFormatException: For input string: "undefined"
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:133)
	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)
	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:888)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634)
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:367)
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:860)
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1598)
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.NumberFormatException: For input string: "undefined"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Long.parseLong(Long.java:589)
	at java.lang.Long.valueOf(Long.java:803)
	at org.springframework.util.NumberUtils.parseNumber(NumberUtils.java:214)
	at org.springframework.beans.propertyeditors.CustomNumberEditor.setAsText(CustomNumberEditor.java:115)
	at org.springframework.beans.TypeConverterDelegate.doConvertTextValue(TypeConverterDelegate.java:429)
	at org.springframework.beans.TypeConverterDelegate.doConvertValue(TypeConverterDelegate.java:402)
	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:155)
	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:73)
	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:53)
	at org.springframework.validation.DataBinder.convertIfNecessary(DataBinder.java:693)
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:125)
	... 47 common frames omitted

2020-02-06 13:32:17.732  WARN 4940 --- [http-nio-8080-exec-10] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.springframework.web.method.annotation.MethodArgumentTypeMismatchException: Failed to convert value of type 'java.lang.String' to required type 'java.lang.Long'; nested exception is java.lang.NumberFormatException: For input string: "undefined"]
2020-02-06 13:34:10.725  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:34:10.730  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:34:29.908  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:34:29.914  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:35:31.852  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:35:31.856  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:36:29.495  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:36:29.499  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:39:00.310  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:39:00.319  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:42:23.399  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:42:23.405  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:45:00.743  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:45:00.753  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:45:39.114  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:45:39.119  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:47:10.466  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:47:10.476  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:47:10.595  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:47:10.600  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:48:07.493  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:48:07.498  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:48:56.892  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:48:56.896  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:49:33.578  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:49:33.582  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:50:40.591  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:50:40.602  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:50:44.576  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:50:44.586  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:50:44.586  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:50:44.600  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:50:44.611  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:50:44.612  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:50:44.623  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:50:44.627  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:50:51.321  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:50:51.328  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:50:51.331  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:50:51.335  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:50:51.354  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:50:51.356  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:50:51.369  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:50:51.379  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:52:51.733  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/64', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[64]}
2020-02-06 13:52:51.739  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=64, title='css实现百叶窗照片墙', content='**项目地址：**[https://github.com/lihaoyuan1/animation/tree/master/jalousie](https://github.com/lihaoyuan1/animation/tree/master/jalousie)
**查看效果：**[http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html](http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html)
因为图片较多，没翻墙的可能加载有些缓慢，稍等片刻即可；
效果图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190715191155784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}
2020-02-06 13:52:56.773  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:52:56.774  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:52:56.784  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:52:56.786  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:52:56.788  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:52:56.793  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:52:56.794  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/64', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[64]}
2020-02-06 13:52:56.799  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=64, title='css实现百叶窗照片墙', content='**项目地址：**[https://github.com/lihaoyuan1/animation/tree/master/jalousie](https://github.com/lihaoyuan1/animation/tree/master/jalousie)
**查看效果：**[http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html](http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html)
因为图片较多，没翻墙的可能加载有些缓慢，稍等片刻即可；
效果图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190715191155784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}
2020-02-06 13:54:12.108  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:54:12.108  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:54:12.117  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:54:12.119  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:54:12.122  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:54:12.125  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:54:12.135  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/64', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[64]}
2020-02-06 13:54:12.144  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=64, title='css实现百叶窗照片墙', content='**项目地址：**[https://github.com/lihaoyuan1/animation/tree/master/jalousie](https://github.com/lihaoyuan1/animation/tree/master/jalousie)
**查看效果：**[http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html](http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html)
因为图片较多，没翻墙的可能加载有些缓慢，稍等片刻即可；
效果图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190715191155784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}
2020-02-06 13:54:19.650  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:54:19.661  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:54:19.662  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:54:19.665  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:54:19.671  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:54:19.675  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:54:19.675  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/64', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[64]}
2020-02-06 13:54:19.681  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=64, title='css实现百叶窗照片墙', content='**项目地址：**[https://github.com/lihaoyuan1/animation/tree/master/jalousie](https://github.com/lihaoyuan1/animation/tree/master/jalousie)
**查看效果：**[http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html](http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html)
因为图片较多，没翻墙的可能加载有些缓慢，稍等片刻即可；
效果图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190715191155784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}
2020-02-06 13:55:08.904  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/64', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[64]}
2020-02-06 13:55:08.906  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:55:08.907  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:55:08.909  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:55:08.912  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=64, title='css实现百叶窗照片墙', content='**项目地址：**[https://github.com/lihaoyuan1/animation/tree/master/jalousie](https://github.com/lihaoyuan1/animation/tree/master/jalousie)
**查看效果：**[http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html](http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html)
因为图片较多，没翻墙的可能加载有些缓慢，稍等片刻即可；
效果图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190715191155784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}
2020-02-06 13:55:08.915  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:55:08.927  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:55:08.936  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:55:30.058  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:55:30.059  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:55:30.069  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:55:30.077  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:55:30.088  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:55:30.089  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/64', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[64]}
2020-02-06 13:55:30.092  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=64, title='css实现百叶窗照片墙', content='**项目地址：**[https://github.com/lihaoyuan1/animation/tree/master/jalousie](https://github.com/lihaoyuan1/animation/tree/master/jalousie)
**查看效果：**[http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html](http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html)
因为图片较多，没翻墙的可能加载有些缓慢，稍等片刻即可；
效果图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190715191155784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}
2020-02-06 13:55:30.094  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:55:52.281  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:55:52.285  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:55:52.291  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:55:52.291  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:55:52.296  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/64', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[64]}
2020-02-06 13:55:52.299  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:55:52.299  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=64, title='css实现百叶窗照片墙', content='**项目地址：**[https://github.com/lihaoyuan1/animation/tree/master/jalousie](https://github.com/lihaoyuan1/animation/tree/master/jalousie)
**查看效果：**[http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html](http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html)
因为图片较多，没翻墙的可能加载有些缓慢，稍等片刻即可；
效果图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190715191155784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}
2020-02-06 13:55:52.300  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:56:00.429  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:56:00.434  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:56:00.443  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:56:00.458  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:56:00.463  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:56:00.468  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:56:00.479  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/64', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[64]}
2020-02-06 13:56:00.482  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=64, title='css实现百叶窗照片墙', content='**项目地址：**[https://github.com/lihaoyuan1/animation/tree/master/jalousie](https://github.com/lihaoyuan1/animation/tree/master/jalousie)
**查看效果：**[http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html](http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html)
因为图片较多，没翻墙的可能加载有些缓慢，稍等片刻即可；
效果图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190715191155784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}
2020-02-06 13:56:19.525  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:56:19.530  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:56:19.534  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:56:19.534  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:56:19.540  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:56:19.545  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:56:19.547  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/64', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[64]}
2020-02-06 13:56:19.551  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=64, title='css实现百叶窗照片墙', content='**项目地址：**[https://github.com/lihaoyuan1/animation/tree/master/jalousie](https://github.com/lihaoyuan1/animation/tree/master/jalousie)
**查看效果：**[http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html](http://htmlpreview.github.io/?https://github.com/lihaoyuan1/animation/blob/master/jalousie/%E7%99%BE%E5%8F%B6%E7%AA%97.html)
因为图片较多，没翻墙的可能加载有些缓慢，稍等片刻即可；
效果图如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190715191155784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}
2020-02-06 13:56:22.543  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:56:22.552  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:56:25.143  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:56:25.148  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:56:46.878  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:56:46.888  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:56:52.223  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:56:52.223  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:56:52.226  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:56:52.231  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:56:52.232  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:56:52.235  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:56:52.258  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:56:52.271  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:56:55.449  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:56:55.453  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:57:02.181  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:57:02.194  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:57:04.600  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/67', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[67]}
2020-02-06 13:57:04.604  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=67, title='表达式求值', content='表达式求值是程序设计编译中的一个最基本的问题，他的实现是栈应用的一个典型范例：

表达式中包含的运算符有`（，），+，-，*，/`，共七种运算符，我们首先要确定这七种运算符的优先级，显然`()`的优先级最高，`*,/`次之，`+,-`的优先级最低，那么`(`与`)`、`+`与`+`、`-`与`-`$$\cdots$$，这些优先级又怎么区分呢？我么用栈求表达式值时是将运算符存在栈中，例如当前栈中有`+`，当再来`+,-`时，显然栈中的`+`可以出栈了，那么栈中`+`的优先级就高于栈外的`+,-`，因此优先级相同的运算符在栈内的优先级应该高于栈外的优先级。下面以表格的形式给出各运算符的优先级：

| 操作符 | # | ( | *,/| +,- | ) |
| :-: | :-: | :-: | :-: | :-: | :-: |
| isp | 0 | 1 | 5 | 3 | 6 |
| icp | 0 | 6 | 4 | 2 | 1 |


其中引入`#`是为了统一运算。
对应的计算优先级的函数如下：

```cpp
int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}
```
这里介绍两种表达式求值的思路：
###### 1. 直接求值法
直接法顾名思义就是直接计算，不需要事先处理表达式；该方法需要两个栈，栈`nsta`存数字，栈`osta`存运算符，一次遍历表达式字符串，这会出现一下几种操作：
1. 当前字符是数字时，直接压入`nsta`；
2. 当前字符是运算符时:
	1. `isp(osta.top) < icp(ch)`，`ch`直接入栈；
	2. `isp(osta.top) > icp(ch)`，`osta.top`出栈，运算结果压入`nsta`，重复步骤1；
	3. `isp(osta.top) == icp(ch)`，只有两种可能，`isp('(') == icp(')')`，`isp('#') == icp('#')`，第一种情况左括号出栈，第二种情况表达式计算结束。

对应直接的直接发代码如下：

```cpp
void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;	//注意顺序
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;	//继续比较osta中的下一个运算符
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());	//nsta中只有一个元素，即为最终结果
}
```
###### 2. 后缀表达式求值
我们的表达式其实是中缀表达式，若将中缀表达式转化为后缀表达式，则只需直接计算即可，不需要考虑优先级的问题，因此将中缀表达式转化为后缀表达式的过程就是按优先级排列运算符，
其中将中缀表达式转化为后缀表达式的代码如下：

```cpp
queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}
```

 这里将后缀表达式存在队列中，同样也可以存在数组中，最后直接计算的代码如下：
 

```cpp
void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

```
最终完整的代码如下：

```cpp
#include <stdio.h>
#include <iostream>
#include <stack>
#include <queue>
#include <cstring>
using namespace std;

int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}

queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}

void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());
}
//  a+b-a*((c+d)/e-f)+g
int main(){
    char str[100];
    queue<char> que;
    scanf("%s", str);
    // 转化为后缀表达式，再通过后缀表达式计算结果
//    que = getSuffix(str);
//    calcSuffix(que);
    // 直接计算
    directCalc(str);
    return 0;
}

```
', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}
2020-02-06 13:57:10.764  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:57:10.776  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:57:14.262  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:57:14.277  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:57:14.294  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:57:14.294  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:57:14.296  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:57:14.299  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:57:14.306  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:57:14.324  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:57:18.190  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/67', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[67]}
2020-02-06 13:57:18.195  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=67, title='表达式求值', content='表达式求值是程序设计编译中的一个最基本的问题，他的实现是栈应用的一个典型范例：

表达式中包含的运算符有`（，），+，-，*，/`，共七种运算符，我们首先要确定这七种运算符的优先级，显然`()`的优先级最高，`*,/`次之，`+,-`的优先级最低，那么`(`与`)`、`+`与`+`、`-`与`-`$$\cdots$$，这些优先级又怎么区分呢？我么用栈求表达式值时是将运算符存在栈中，例如当前栈中有`+`，当再来`+,-`时，显然栈中的`+`可以出栈了，那么栈中`+`的优先级就高于栈外的`+,-`，因此优先级相同的运算符在栈内的优先级应该高于栈外的优先级。下面以表格的形式给出各运算符的优先级：

| 操作符 | # | ( | *,/| +,- | ) |
| :-: | :-: | :-: | :-: | :-: | :-: |
| isp | 0 | 1 | 5 | 3 | 6 |
| icp | 0 | 6 | 4 | 2 | 1 |


其中引入`#`是为了统一运算。
对应的计算优先级的函数如下：

```cpp
int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}
```
这里介绍两种表达式求值的思路：
###### 1. 直接求值法
直接法顾名思义就是直接计算，不需要事先处理表达式；该方法需要两个栈，栈`nsta`存数字，栈`osta`存运算符，一次遍历表达式字符串，这会出现一下几种操作：
1. 当前字符是数字时，直接压入`nsta`；
2. 当前字符是运算符时:
	1. `isp(osta.top) < icp(ch)`，`ch`直接入栈；
	2. `isp(osta.top) > icp(ch)`，`osta.top`出栈，运算结果压入`nsta`，重复步骤1；
	3. `isp(osta.top) == icp(ch)`，只有两种可能，`isp('(') == icp(')')`，`isp('#') == icp('#')`，第一种情况左括号出栈，第二种情况表达式计算结束。

对应直接的直接发代码如下：

```cpp
void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;	//注意顺序
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;	//继续比较osta中的下一个运算符
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());	//nsta中只有一个元素，即为最终结果
}
```
###### 2. 后缀表达式求值
我们的表达式其实是中缀表达式，若将中缀表达式转化为后缀表达式，则只需直接计算即可，不需要考虑优先级的问题，因此将中缀表达式转化为后缀表达式的过程就是按优先级排列运算符，
其中将中缀表达式转化为后缀表达式的代码如下：

```cpp
queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}
```

 这里将后缀表达式存在队列中，同样也可以存在数组中，最后直接计算的代码如下：
 

```cpp
void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

```
最终完整的代码如下：

```cpp
#include <stdio.h>
#include <iostream>
#include <stack>
#include <queue>
#include <cstring>
using namespace std;

int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}

queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}

void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());
}
//  a+b-a*((c+d)/e-f)+g
int main(){
    char str[100];
    queue<char> que;
    scanf("%s", str);
    // 转化为后缀表达式，再通过后缀表达式计算结果
//    que = getSuffix(str);
//    calcSuffix(que);
    // 直接计算
    directCalc(str);
    return 0;
}

```
', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}
2020-02-06 13:57:21.103  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:57:21.115  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:57:22.857  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:57:22.862  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:59:34.441  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:59:34.444  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:59:34.452  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:59:34.455  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:59:34.457  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:59:34.459  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:59:34.461  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:59:34.461  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:59:39.522  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:59:39.535  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:59:39.545  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:59:39.553  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:59:39.555  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:59:39.568  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:59:39.570  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:59:39.573  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:59:41.576  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:59:41.588  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:59:45.276  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 13:59:45.279  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 13:59:49.589  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:59:49.614  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 13:59:53.646  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 13:59:53.652  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 13:59:53.653  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 13:59:53.654  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 13:59:53.659  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 13:59:53.664  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 13:59:53.667  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 13:59:53.675  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:03:20.956  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:03:20.965  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:03:20.990  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:03:20.990  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:03:20.993  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:03:20.998  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:03:21.010  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:03:21.011  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:03:23.557  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:03:23.561  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:03:29.376  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:03:29.382  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:03:29.390  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:03:29.393  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:03:29.401  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:03:29.405  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:03:29.409  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:03:29.413  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:03:31.601  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:03:31.608  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:03:34.640  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:03:34.645  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:03:57.079  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:03:57.086  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:03:57.091  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:03:57.091  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:03:57.095  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:03:57.106  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:03:57.116  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:03:57.124  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:06:56.028  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:06:56.032  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:08:06.448  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:08:06.453  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:08:07.082  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:08:07.087  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:08:26.664  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:08:26.668  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:09:25.058  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:09:25.061  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:09:25.072  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:09:25.076  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:09:25.083  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:09:25.083  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:09:25.087  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:09:25.088  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:09:29.865  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:09:29.875  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:09:29.888  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:09:29.891  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:09:29.893  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:09:29.901  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:09:29.901  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:09:29.908  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:09:32.094  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:09:32.105  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:09:34.391  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:09:34.394  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:09:49.767  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:09:49.768  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:09:49.775  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:09:49.780  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:09:49.785  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:09:49.785  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:09:49.788  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:09:49.791  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:11:43.901  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:11:43.905  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:11:47.117  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:11:47.120  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:11:47.128  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:11:47.135  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:11:47.139  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:11:47.144  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:11:47.147  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:11:47.154  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:12:13.241  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:12:13.254  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:12:13.268  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:12:13.273  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:12:13.275  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:12:13.283  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:12:13.284  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:12:13.285  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:13:24.529  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:13:24.541  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:20:00.077  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:20:00.083  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:20:04.024  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:20:04.030  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:20:04.039  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:20:04.041  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:20:04.048  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:20:04.052  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:20:04.066  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:20:04.070  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:20:09.686  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:20:09.686  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:20:09.686  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:20:09.691  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:20:09.697  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:20:09.700  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:20:09.703  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:20:09.712  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:21:23.449  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:21:23.449  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:21:23.458  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:21:23.462  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:21:23.468  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:21:23.472  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:21:23.473  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:21:23.475  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:21:30.026  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:21:30.028  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:21:30.034  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:21:30.040  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:21:30.041  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:21:30.042  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:21:30.045  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:21:30.046  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:21:52.698  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:21:52.711  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:21:52.725  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:21:52.739  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:21:52.739  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:21:52.744  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:21:52.747  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:21:52.750  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:21:55.489  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:21:55.496  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:04.340  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:22:04.343  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:22:06.694  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:06.704  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:08.621  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/67', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[67]}
2020-02-06 14:22:08.627  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=67, title='表达式求值', content='表达式求值是程序设计编译中的一个最基本的问题，他的实现是栈应用的一个典型范例：

表达式中包含的运算符有`（，），+，-，*，/`，共七种运算符，我们首先要确定这七种运算符的优先级，显然`()`的优先级最高，`*,/`次之，`+,-`的优先级最低，那么`(`与`)`、`+`与`+`、`-`与`-`$$\cdots$$，这些优先级又怎么区分呢？我么用栈求表达式值时是将运算符存在栈中，例如当前栈中有`+`，当再来`+,-`时，显然栈中的`+`可以出栈了，那么栈中`+`的优先级就高于栈外的`+,-`，因此优先级相同的运算符在栈内的优先级应该高于栈外的优先级。下面以表格的形式给出各运算符的优先级：

| 操作符 | # | ( | *,/| +,- | ) |
| :-: | :-: | :-: | :-: | :-: | :-: |
| isp | 0 | 1 | 5 | 3 | 6 |
| icp | 0 | 6 | 4 | 2 | 1 |


其中引入`#`是为了统一运算。
对应的计算优先级的函数如下：

```cpp
int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}
```
这里介绍两种表达式求值的思路：
###### 1. 直接求值法
直接法顾名思义就是直接计算，不需要事先处理表达式；该方法需要两个栈，栈`nsta`存数字，栈`osta`存运算符，一次遍历表达式字符串，这会出现一下几种操作：
1. 当前字符是数字时，直接压入`nsta`；
2. 当前字符是运算符时:
	1. `isp(osta.top) < icp(ch)`，`ch`直接入栈；
	2. `isp(osta.top) > icp(ch)`，`osta.top`出栈，运算结果压入`nsta`，重复步骤1；
	3. `isp(osta.top) == icp(ch)`，只有两种可能，`isp('(') == icp(')')`，`isp('#') == icp('#')`，第一种情况左括号出栈，第二种情况表达式计算结束。

对应直接的直接发代码如下：

```cpp
void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;	//注意顺序
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;	//继续比较osta中的下一个运算符
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());	//nsta中只有一个元素，即为最终结果
}
```
###### 2. 后缀表达式求值
我们的表达式其实是中缀表达式，若将中缀表达式转化为后缀表达式，则只需直接计算即可，不需要考虑优先级的问题，因此将中缀表达式转化为后缀表达式的过程就是按优先级排列运算符，
其中将中缀表达式转化为后缀表达式的代码如下：

```cpp
queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}
```

 这里将后缀表达式存在队列中，同样也可以存在数组中，最后直接计算的代码如下：
 

```cpp
void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

```
最终完整的代码如下：

```cpp
#include <stdio.h>
#include <iostream>
#include <stack>
#include <queue>
#include <cstring>
using namespace std;

int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}

queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}

void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());
}
//  a+b-a*((c+d)/e-f)+g
int main(){
    char str[100];
    queue<char> que;
    scanf("%s", str);
    // 转化为后缀表达式，再通过后缀表达式计算结果
//    que = getSuffix(str);
//    calcSuffix(que);
    // 直接计算
    directCalc(str);
    return 0;
}

```
', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}
2020-02-06 14:22:10.484  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:10.492  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:11.797  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:22:11.800  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:22:13.067  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:13.077  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:14.544  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:22:14.548  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:22:15.944  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:15.953  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:17.621  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 14:22:17.625  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 14:22:19.203  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:19.214  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:20.541  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 14:22:20.547  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 14:22:22.070  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:22.075  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:23.712  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:22:23.718  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:22:32.104  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:32.114  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:35.071  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:22:35.080  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:22:35.093  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:22:35.095  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:22:35.098  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:35.100  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:22:35.164  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:35.169  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:22:39.406  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/67', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[67]}
2020-02-06 14:22:39.411  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=67, title='表达式求值', content='表达式求值是程序设计编译中的一个最基本的问题，他的实现是栈应用的一个典型范例：

表达式中包含的运算符有`（，），+，-，*，/`，共七种运算符，我们首先要确定这七种运算符的优先级，显然`()`的优先级最高，`*,/`次之，`+,-`的优先级最低，那么`(`与`)`、`+`与`+`、`-`与`-`$$\cdots$$，这些优先级又怎么区分呢？我么用栈求表达式值时是将运算符存在栈中，例如当前栈中有`+`，当再来`+,-`时，显然栈中的`+`可以出栈了，那么栈中`+`的优先级就高于栈外的`+,-`，因此优先级相同的运算符在栈内的优先级应该高于栈外的优先级。下面以表格的形式给出各运算符的优先级：

| 操作符 | # | ( | *,/| +,- | ) |
| :-: | :-: | :-: | :-: | :-: | :-: |
| isp | 0 | 1 | 5 | 3 | 6 |
| icp | 0 | 6 | 4 | 2 | 1 |


其中引入`#`是为了统一运算。
对应的计算优先级的函数如下：

```cpp
int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}
```
这里介绍两种表达式求值的思路：
###### 1. 直接求值法
直接法顾名思义就是直接计算，不需要事先处理表达式；该方法需要两个栈，栈`nsta`存数字，栈`osta`存运算符，一次遍历表达式字符串，这会出现一下几种操作：
1. 当前字符是数字时，直接压入`nsta`；
2. 当前字符是运算符时:
	1. `isp(osta.top) < icp(ch)`，`ch`直接入栈；
	2. `isp(osta.top) > icp(ch)`，`osta.top`出栈，运算结果压入`nsta`，重复步骤1；
	3. `isp(osta.top) == icp(ch)`，只有两种可能，`isp('(') == icp(')')`，`isp('#') == icp('#')`，第一种情况左括号出栈，第二种情况表达式计算结束。

对应直接的直接发代码如下：

```cpp
void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;	//注意顺序
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;	//继续比较osta中的下一个运算符
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());	//nsta中只有一个元素，即为最终结果
}
```
###### 2. 后缀表达式求值
我们的表达式其实是中缀表达式，若将中缀表达式转化为后缀表达式，则只需直接计算即可，不需要考虑优先级的问题，因此将中缀表达式转化为后缀表达式的过程就是按优先级排列运算符，
其中将中缀表达式转化为后缀表达式的代码如下：

```cpp
queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}
```

 这里将后缀表达式存在队列中，同样也可以存在数组中，最后直接计算的代码如下：
 

```cpp
void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

```
最终完整的代码如下：

```cpp
#include <stdio.h>
#include <iostream>
#include <stack>
#include <queue>
#include <cstring>
using namespace std;

int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}

queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}

void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());
}
//  a+b-a*((c+d)/e-f)+g
int main(){
    char str[100];
    queue<char> que;
    scanf("%s", str);
    // 转化为后缀表达式，再通过后缀表达式计算结果
//    que = getSuffix(str);
//    calcSuffix(que);
    // 直接计算
    directCalc(str);
    return 0;
}

```
', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}
2020-02-06 14:22:41.708  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:41.714  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:43.242  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:22:43.245  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:22:44.731  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:44.737  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:46.137  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:22:46.140  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:22:47.474  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:47.483  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:48.525  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:22:48.531  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:22:49.740  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:49.752  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:51.513  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/67', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[67]}
2020-02-06 14:22:51.517  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=67, title='表达式求值', content='表达式求值是程序设计编译中的一个最基本的问题，他的实现是栈应用的一个典型范例：

表达式中包含的运算符有`（，），+，-，*，/`，共七种运算符，我们首先要确定这七种运算符的优先级，显然`()`的优先级最高，`*,/`次之，`+,-`的优先级最低，那么`(`与`)`、`+`与`+`、`-`与`-`$$\cdots$$，这些优先级又怎么区分呢？我么用栈求表达式值时是将运算符存在栈中，例如当前栈中有`+`，当再来`+,-`时，显然栈中的`+`可以出栈了，那么栈中`+`的优先级就高于栈外的`+,-`，因此优先级相同的运算符在栈内的优先级应该高于栈外的优先级。下面以表格的形式给出各运算符的优先级：

| 操作符 | # | ( | *,/| +,- | ) |
| :-: | :-: | :-: | :-: | :-: | :-: |
| isp | 0 | 1 | 5 | 3 | 6 |
| icp | 0 | 6 | 4 | 2 | 1 |


其中引入`#`是为了统一运算。
对应的计算优先级的函数如下：

```cpp
int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}
```
这里介绍两种表达式求值的思路：
###### 1. 直接求值法
直接法顾名思义就是直接计算，不需要事先处理表达式；该方法需要两个栈，栈`nsta`存数字，栈`osta`存运算符，一次遍历表达式字符串，这会出现一下几种操作：
1. 当前字符是数字时，直接压入`nsta`；
2. 当前字符是运算符时:
	1. `isp(osta.top) < icp(ch)`，`ch`直接入栈；
	2. `isp(osta.top) > icp(ch)`，`osta.top`出栈，运算结果压入`nsta`，重复步骤1；
	3. `isp(osta.top) == icp(ch)`，只有两种可能，`isp('(') == icp(')')`，`isp('#') == icp('#')`，第一种情况左括号出栈，第二种情况表达式计算结束。

对应直接的直接发代码如下：

```cpp
void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;	//注意顺序
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;	//继续比较osta中的下一个运算符
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());	//nsta中只有一个元素，即为最终结果
}
```
###### 2. 后缀表达式求值
我们的表达式其实是中缀表达式，若将中缀表达式转化为后缀表达式，则只需直接计算即可，不需要考虑优先级的问题，因此将中缀表达式转化为后缀表达式的过程就是按优先级排列运算符，
其中将中缀表达式转化为后缀表达式的代码如下：

```cpp
queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}
```

 这里将后缀表达式存在队列中，同样也可以存在数组中，最后直接计算的代码如下：
 

```cpp
void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

```
最终完整的代码如下：

```cpp
#include <stdio.h>
#include <iostream>
#include <stack>
#include <queue>
#include <cstring>
using namespace std;

int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}

queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}

void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());
}
//  a+b-a*((c+d)/e-f)+g
int main(){
    char str[100];
    queue<char> que;
    scanf("%s", str);
    // 转化为后缀表达式，再通过后缀表达式计算结果
//    que = getSuffix(str);
//    calcSuffix(que);
    // 直接计算
    directCalc(str);
    return 0;
}

```
', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}
2020-02-06 14:22:52.882  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:52.891  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:54.172  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:22:54.177  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:22:55.585  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:55.593  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:57.067  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/67', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[67]}
2020-02-06 14:22:57.071  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=67, title='表达式求值', content='表达式求值是程序设计编译中的一个最基本的问题，他的实现是栈应用的一个典型范例：

表达式中包含的运算符有`（，），+，-，*，/`，共七种运算符，我们首先要确定这七种运算符的优先级，显然`()`的优先级最高，`*,/`次之，`+,-`的优先级最低，那么`(`与`)`、`+`与`+`、`-`与`-`$$\cdots$$，这些优先级又怎么区分呢？我么用栈求表达式值时是将运算符存在栈中，例如当前栈中有`+`，当再来`+,-`时，显然栈中的`+`可以出栈了，那么栈中`+`的优先级就高于栈外的`+,-`，因此优先级相同的运算符在栈内的优先级应该高于栈外的优先级。下面以表格的形式给出各运算符的优先级：

| 操作符 | # | ( | *,/| +,- | ) |
| :-: | :-: | :-: | :-: | :-: | :-: |
| isp | 0 | 1 | 5 | 3 | 6 |
| icp | 0 | 6 | 4 | 2 | 1 |


其中引入`#`是为了统一运算。
对应的计算优先级的函数如下：

```cpp
int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}
```
这里介绍两种表达式求值的思路：
###### 1. 直接求值法
直接法顾名思义就是直接计算，不需要事先处理表达式；该方法需要两个栈，栈`nsta`存数字，栈`osta`存运算符，一次遍历表达式字符串，这会出现一下几种操作：
1. 当前字符是数字时，直接压入`nsta`；
2. 当前字符是运算符时:
	1. `isp(osta.top) < icp(ch)`，`ch`直接入栈；
	2. `isp(osta.top) > icp(ch)`，`osta.top`出栈，运算结果压入`nsta`，重复步骤1；
	3. `isp(osta.top) == icp(ch)`，只有两种可能，`isp('(') == icp(')')`，`isp('#') == icp('#')`，第一种情况左括号出栈，第二种情况表达式计算结束。

对应直接的直接发代码如下：

```cpp
void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;	//注意顺序
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;	//继续比较osta中的下一个运算符
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());	//nsta中只有一个元素，即为最终结果
}
```
###### 2. 后缀表达式求值
我们的表达式其实是中缀表达式，若将中缀表达式转化为后缀表达式，则只需直接计算即可，不需要考虑优先级的问题，因此将中缀表达式转化为后缀表达式的过程就是按优先级排列运算符，
其中将中缀表达式转化为后缀表达式的代码如下：

```cpp
queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}
```

 这里将后缀表达式存在队列中，同样也可以存在数组中，最后直接计算的代码如下：
 

```cpp
void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

```
最终完整的代码如下：

```cpp
#include <stdio.h>
#include <iostream>
#include <stack>
#include <queue>
#include <cstring>
using namespace std;

int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}

queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}

void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());
}
//  a+b-a*((c+d)/e-f)+g
int main(){
    char str[100];
    queue<char> que;
    scanf("%s", str);
    // 转化为后缀表达式，再通过后缀表达式计算结果
//    que = getSuffix(str);
//    calcSuffix(que);
    // 直接计算
    directCalc(str);
    return 0;
}

```
', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}
2020-02-06 14:22:58.379  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:22:58.387  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:22:59.835  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:22:59.841  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:23:01.088  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:23:01.097  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:23:02.492  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/67', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[67]}
2020-02-06 14:23:02.496  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=67, title='表达式求值', content='表达式求值是程序设计编译中的一个最基本的问题，他的实现是栈应用的一个典型范例：

表达式中包含的运算符有`（，），+，-，*，/`，共七种运算符，我们首先要确定这七种运算符的优先级，显然`()`的优先级最高，`*,/`次之，`+,-`的优先级最低，那么`(`与`)`、`+`与`+`、`-`与`-`$$\cdots$$，这些优先级又怎么区分呢？我么用栈求表达式值时是将运算符存在栈中，例如当前栈中有`+`，当再来`+,-`时，显然栈中的`+`可以出栈了，那么栈中`+`的优先级就高于栈外的`+,-`，因此优先级相同的运算符在栈内的优先级应该高于栈外的优先级。下面以表格的形式给出各运算符的优先级：

| 操作符 | # | ( | *,/| +,- | ) |
| :-: | :-: | :-: | :-: | :-: | :-: |
| isp | 0 | 1 | 5 | 3 | 6 |
| icp | 0 | 6 | 4 | 2 | 1 |


其中引入`#`是为了统一运算。
对应的计算优先级的函数如下：

```cpp
int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}
```
这里介绍两种表达式求值的思路：
###### 1. 直接求值法
直接法顾名思义就是直接计算，不需要事先处理表达式；该方法需要两个栈，栈`nsta`存数字，栈`osta`存运算符，一次遍历表达式字符串，这会出现一下几种操作：
1. 当前字符是数字时，直接压入`nsta`；
2. 当前字符是运算符时:
	1. `isp(osta.top) < icp(ch)`，`ch`直接入栈；
	2. `isp(osta.top) > icp(ch)`，`osta.top`出栈，运算结果压入`nsta`，重复步骤1；
	3. `isp(osta.top) == icp(ch)`，只有两种可能，`isp('(') == icp(')')`，`isp('#') == icp('#')`，第一种情况左括号出栈，第二种情况表达式计算结束。

对应直接的直接发代码如下：

```cpp
void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;	//注意顺序
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;	//继续比较osta中的下一个运算符
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());	//nsta中只有一个元素，即为最终结果
}
```
###### 2. 后缀表达式求值
我们的表达式其实是中缀表达式，若将中缀表达式转化为后缀表达式，则只需直接计算即可，不需要考虑优先级的问题，因此将中缀表达式转化为后缀表达式的过程就是按优先级排列运算符，
其中将中缀表达式转化为后缀表达式的代码如下：

```cpp
queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}
```

 这里将后缀表达式存在队列中，同样也可以存在数组中，最后直接计算的代码如下：
 

```cpp
void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

```
最终完整的代码如下：

```cpp
#include <stdio.h>
#include <iostream>
#include <stack>
#include <queue>
#include <cstring>
using namespace std;

int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}

queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}

void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());
}
//  a+b-a*((c+d)/e-f)+g
int main(){
    char str[100];
    queue<char> que;
    scanf("%s", str);
    // 转化为后缀表达式，再通过后缀表达式计算结果
//    que = getSuffix(str);
//    calcSuffix(que);
    // 直接计算
    directCalc(str);
    return 0;
}

```
', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}
2020-02-06 14:23:04.153  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:23:04.160  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:23:05.531  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/67', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[67]}
2020-02-06 14:23:05.536  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=67, title='表达式求值', content='表达式求值是程序设计编译中的一个最基本的问题，他的实现是栈应用的一个典型范例：

表达式中包含的运算符有`（，），+，-，*，/`，共七种运算符，我们首先要确定这七种运算符的优先级，显然`()`的优先级最高，`*,/`次之，`+,-`的优先级最低，那么`(`与`)`、`+`与`+`、`-`与`-`$$\cdots$$，这些优先级又怎么区分呢？我么用栈求表达式值时是将运算符存在栈中，例如当前栈中有`+`，当再来`+,-`时，显然栈中的`+`可以出栈了，那么栈中`+`的优先级就高于栈外的`+,-`，因此优先级相同的运算符在栈内的优先级应该高于栈外的优先级。下面以表格的形式给出各运算符的优先级：

| 操作符 | # | ( | *,/| +,- | ) |
| :-: | :-: | :-: | :-: | :-: | :-: |
| isp | 0 | 1 | 5 | 3 | 6 |
| icp | 0 | 6 | 4 | 2 | 1 |


其中引入`#`是为了统一运算。
对应的计算优先级的函数如下：

```cpp
int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}
```
这里介绍两种表达式求值的思路：
###### 1. 直接求值法
直接法顾名思义就是直接计算，不需要事先处理表达式；该方法需要两个栈，栈`nsta`存数字，栈`osta`存运算符，一次遍历表达式字符串，这会出现一下几种操作：
1. 当前字符是数字时，直接压入`nsta`；
2. 当前字符是运算符时:
	1. `isp(osta.top) < icp(ch)`，`ch`直接入栈；
	2. `isp(osta.top) > icp(ch)`，`osta.top`出栈，运算结果压入`nsta`，重复步骤1；
	3. `isp(osta.top) == icp(ch)`，只有两种可能，`isp('(') == icp(')')`，`isp('#') == icp('#')`，第一种情况左括号出栈，第二种情况表达式计算结束。

对应直接的直接发代码如下：

```cpp
void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;	//注意顺序
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;	//继续比较osta中的下一个运算符
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());	//nsta中只有一个元素，即为最终结果
}
```
###### 2. 后缀表达式求值
我们的表达式其实是中缀表达式，若将中缀表达式转化为后缀表达式，则只需直接计算即可，不需要考虑优先级的问题，因此将中缀表达式转化为后缀表达式的过程就是按优先级排列运算符，
其中将中缀表达式转化为后缀表达式的代码如下：

```cpp
queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}
```

 这里将后缀表达式存在队列中，同样也可以存在数组中，最后直接计算的代码如下：
 

```cpp
void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

```
最终完整的代码如下：

```cpp
#include <stdio.h>
#include <iostream>
#include <stack>
#include <queue>
#include <cstring>
using namespace std;

int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}

queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}

void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());
}
//  a+b-a*((c+d)/e-f)+g
int main(){
    char str[100];
    queue<char> que;
    scanf("%s", str);
    // 转化为后缀表达式，再通过后缀表达式计算结果
//    que = getSuffix(str);
//    calcSuffix(que);
    // 直接计算
    directCalc(str);
    return 0;
}

```
', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}
2020-02-06 14:23:07.819  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:23:07.832  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:23:10.881  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/132', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[132]}
2020-02-06 14:23:10.884  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=132, title='123', content='123', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}
2020-02-06 14:23:12.315  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:23:12.323  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:23:13.867  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:23:13.872  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:23:15.251  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:23:15.259  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:23:16.333  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:23:16.335  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:23:19.709  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:23:19.710  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:23:19.721  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:23:19.727  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:23:19.735  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:23:19.740  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:23:19.741  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:23:19.744  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:23:25.487  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:23:25.492  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:23:25.497  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:23:25.504  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:23:25.508  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:23:25.508  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:23:25.511  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:23:25.512  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:23:43.660  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:23:43.663  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:23:43.670  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:23:43.678  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:23:43.685  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:23:43.686  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:23:43.689  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:23:43.690  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:23:49.152  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:23:49.160  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:23:49.161  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:23:49.161  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:23:49.161  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:23:49.164  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:23:49.166  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:23:49.176  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:26:16.853  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:26:16.855  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:26:16.866  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:26:16.875  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:26:16.881  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:26:16.881  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:26:16.887  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:26:16.888  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:26:19.920  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:26:19.926  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:26:23.309  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:26:23.310  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:26:23.315  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:26:23.317  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:26:23.319  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:26:23.322  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:26:23.329  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:26:23.341  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:26:26.525  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:26:26.530  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:26:30.353  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:26:30.364  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:26:30.364  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:26:30.365  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:26:30.367  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:26:30.370  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:26:30.371  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:26:30.377  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:26:35.585  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:26:35.591  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:26:35.594  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:26:35.604  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:26:35.610  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:26:35.613  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:26:35.615  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:26:35.616  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:26:44.146  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:26:44.154  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:26:44.157  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:26:44.172  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:26:44.173  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:26:44.174  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:26:44.182  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:26:44.182  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:27:41.340  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:27:41.346  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:27:45.325  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:27:45.328  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:27:45.337  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:27:45.342  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:27:45.344  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:27:45.345  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:27:45.348  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:27:45.348  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:29:33.857  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:29:33.866  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:29:36.036  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:29:36.041  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:33:28.063  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:33:28.067  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:33:28.074  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:33:28.080  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:33:28.080  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:33:28.081  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:33:28.084  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:33:28.085  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:35:02.326  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:35:02.337  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:35:02.350  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:35:02.358  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:35:02.370  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:35:02.373  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:35:02.375  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:35:02.383  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:35:08.860  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:35:08.869  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:35:08.899  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:35:08.912  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:35:08.922  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:35:08.927  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:35:08.936  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:35:08.940  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:36:38.660  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:36:38.669  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:36:38.673  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:36:38.686  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:36:38.691  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:36:38.697  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:36:38.698  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:36:38.702  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:37:09.886  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:37:09.889  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:37:09.895  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:37:09.900  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:37:09.902  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:37:09.904  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:37:09.906  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:37:09.907  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:37:19.250  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:37:19.264  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:37:19.277  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:37:19.277  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:37:19.279  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:37:19.282  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:37:19.282  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:37:19.289  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:37:24.413  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:37:24.414  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:37:24.423  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:37:24.428  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:37:24.432  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:37:24.432  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:37:24.437  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:37:24.439  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:37:48.937  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:37:48.943  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:37:48.945  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:37:48.955  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:37:48.960  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:37:48.965  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:37:48.974  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:37:48.983  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:38:09.456  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:38:09.463  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:38:09.465  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:38:09.474  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:38:09.474  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:38:09.476  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:38:09.478  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:38:09.480  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:42:35.027  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:42:35.028  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:42:35.036  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:42:35.044  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:42:35.047  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:42:35.048  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:42:35.060  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:42:35.066  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:43:39.461  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:43:39.461  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:43:39.467  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:43:39.479  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:43:39.479  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:43:39.485  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:43:39.496  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:43:39.504  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:46:02.784  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:46:02.790  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:46:02.790  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:46:02.795  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:46:02.797  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:46:02.804  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:46:02.806  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:46:02.813  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:50:57.089  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:50:57.101  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:50:57.103  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:50:57.114  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:50:57.114  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:50:57.116  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:50:57.121  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:50:57.123  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:51:02.212  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:51:02.218  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:51:09.972  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:51:09.972  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:51:09.984  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:51:09.990  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:51:09.995  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:51:10.002  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:51:10.006  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:51:10.012  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:54:57.492  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:54:57.494  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:54:57.495  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:54:57.499  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:54:57.512  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 14:54:57.530  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:54:57.540  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 14:54:57.543  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:55:06.331  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 14:55:06.341  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 14:55:14.257  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 14:55:14.260  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 14:56:25.102  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 14:56:25.105  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 14:57:42.157  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 14:57:42.161  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 14:57:51.611  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:57:51.613  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:57:51.623  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:57:51.629  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:57:51.631  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:57:51.633  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 14:57:51.637  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:57:51.639  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 14:57:58.492  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 14:57:58.496  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 14:57:58.507  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 14:57:58.508  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 14:57:58.513  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 14:57:58.517  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 14:57:58.523  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 14:57:58.526  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 14:58:21.586  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 14:58:21.589  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 14:59:20.519  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 14:59:20.523  INFO 4940 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 15:04:20.875  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 15:04:20.876  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 15:04:20.877  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 15:04:20.881  INFO 4940 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 15:04:20.884  INFO 4940 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 15:04:20.889  INFO 4940 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 15:04:20.891  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 15:04:20.895  INFO 4940 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 15:06:21.981  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 15:06:21.989  INFO 4940 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 15:06:34.503  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 15:06:34.506  INFO 4940 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 15:07:00.093  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 15:07:00.099  INFO 4940 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 15:07:24.525  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 15:07:24.529  INFO 4940 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 15:07:55.483  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/57', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[57]}
2020-02-06 15:07:55.486  INFO 4940 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='#### 题目
给定一个大小为$$N\times M$$的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动，请求出从起点到终点所需的最小步数。限制条件$$N,M \le 100$$
#### 输入
（`'#'`,`'.'`,`'S'`,`'G'`分别表示墙壁、通道、起点和终点）
>$$N=10, M=12$$
>`#S######.#`
>`......#..#`
>`.#.##.##.#`
>`.#........`
>`##.##.####`
>`....#....#`
>`.#######.#`
>`....#.....`
>`.####.###.`
>`....#...G#`

#### 输出
>22

#### 分析
宽度优先搜索按照距开始状态由近即远的顺序进行搜索，因此可以很容易地用来求最短路径、最少操作之类问题的答案。

可以用`d[N][M]`数组把最短距离保存起来，用充分大得常数`INF`来初始化，这样一来，尚未到达的位置就是`INF`。

因为要向四个方向移动，用`dx[4]`和`dy[4]`两个数组来表示四个方向向量，通过循环就可以实现四个方向移动得遍历。

#### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define MAX_SIZE 100
#define INF 100000000

struct Place{
    int x;
    int y;
};

char maze[MAX_SIZE][MAX_SIZE+1];
int d[MAX_SIZE][MAX_SIZE];

void bfs(Place s, Place g, int n, int m){
	// 四个移动方向，对应右、下、左、上
    int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};
    // 初始化距离数组，赋一个较大值INF
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            d[i][j] = INF;
    queue<Place> que;
    que.push(s);
    d[s.x][s.y] = 0;
    while(!que.empty()){
        Place p = que.front();
        que.pop();
        // 找到出口
        if(p.x == g.x && p.y == g.y)
            break;
        for(int i=0; i<4; i++){
            int nx = p.x + dx[i], ny = p.y + dy[i];
            if(0 <= nx && nx < n && 0 <= ny && ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF){
                Place tmp;
                tmp.x = nx;
                tmp.y = ny;
                que.push(tmp);
                // 当前位置可走通，则距离加一
                d[nx][ny] = d[p.x][p.y] + 1;
            }
        }
    }
    //若输出INF则为死迷宫，反之，输出的是最短距离
    printf("%d\n", d[g.x][g.y]);
}

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i=0; i<n; i++)
        scanf("%s", maze[i]);
    Place s, g;
    // 查询迷宫开始和结束位置
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(maze[i][j] == 'S'){
                s.x = i;
                s.y = j;
            }
            if(maze[i][j] == 'G'){
                g.x = i;
                g.y = j;
            }
        }
    }
    // bfs遍历
    bfs(s, g, n, m);
    return 0;
}

```
#### 输出
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190730121123906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}
2020-02-06 16:08:11.099  INFO 10932 --- [restartedMain] com.lhy.blog.BlogApplication             : Starting BlogApplication on DESKTOP-KCJEFBA with PID 10932 (E:\CODE\Java\blog\target\classes started by 16177 in E:\CODE\Java\blog)
2020-02-06 16:08:11.103 DEBUG 10932 --- [restartedMain] com.lhy.blog.BlogApplication             : Running with Spring Boot v2.2.4.RELEASE, Spring v5.2.3.RELEASE
2020-02-06 16:08:11.105  INFO 10932 --- [restartedMain] com.lhy.blog.BlogApplication             : The following profiles are active: dev
2020-02-06 16:08:11.237  INFO 10932 --- [restartedMain] o.s.b.devtools.restart.ChangeableUrls    : The Class-Path manifest attribute in C:\Users\16177\.m2\repository\org\glassfish\jaxb\jaxb-runtime\2.3.2\jaxb-runtime-2.3.2.jar referenced one or more files that do not exist: file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/jakarta.xml.bind-api-2.3.2.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/txw2-2.3.2.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/istack-commons-runtime-3.0.8.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/stax-ex-1.8.1.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/FastInfoset-1.2.16.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/jakarta.activation-api-1.2.1.jar
2020-02-06 16:08:11.238  INFO 10932 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-02-06 16:08:11.238  INFO 10932 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-02-06 16:08:13.239  INFO 10932 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2020-02-06 16:08:13.435  INFO 10932 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 175ms. Found 5 JPA repository interfaces.
2020-02-06 16:08:14.267  INFO 10932 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-02-06 16:08:15.529  INFO 10932 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2020-02-06 16:08:15.556  INFO 10932 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-06 16:08:15.556  INFO 10932 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.30]
2020-02-06 16:08:15.783  INFO 10932 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-06 16:08:15.785  INFO 10932 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 4545 ms
2020-02-06 16:08:16.404  INFO 10932 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2020-02-06 16:08:16.575  INFO 10932 --- [restartedMain] org.hibernate.Version                    : HHH000412: Hibernate Core {5.4.10.Final}
2020-02-06 16:08:16.887  INFO 10932 --- [restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.0.Final}
2020-02-06 16:08:17.153  INFO 10932 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-02-06 16:08:17.424  INFO 10932 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-02-06 16:08:17.481  INFO 10932 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL57Dialect
2020-02-06 16:08:20.172  INFO 10932 --- [restartedMain] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2020-02-06 16:08:20.185  INFO 10932 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-06 16:08:20.349  INFO 10932 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-06 16:08:22.075  WARN 10932 --- [restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2020-02-06 16:08:22.546  INFO 10932 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-02-06 16:08:22.709  INFO 10932 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-02-06 16:08:23.624  INFO 10932 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2020-02-06 16:08:23.629  INFO 10932 --- [restartedMain] com.lhy.blog.BlogApplication             : Started BlogApplication in 13.973 seconds (JVM running for 16.36)
2020-02-06 16:09:38.817  INFO 10932 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-02-06 16:09:38.818  INFO 10932 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-02-06 16:09:38.856  INFO 10932 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 38 ms
2020-02-06 16:14:24.549  INFO 15892 --- [restartedMain] com.lhy.blog.BlogApplication             : Starting BlogApplication on DESKTOP-KCJEFBA with PID 15892 (E:\CODE\Java\blog\target\classes started by 16177 in E:\CODE\Java\blog)
2020-02-06 16:14:24.557 DEBUG 15892 --- [restartedMain] com.lhy.blog.BlogApplication             : Running with Spring Boot v2.2.4.RELEASE, Spring v5.2.3.RELEASE
2020-02-06 16:14:24.558  INFO 15892 --- [restartedMain] com.lhy.blog.BlogApplication             : The following profiles are active: dev
2020-02-06 16:14:24.645  INFO 15892 --- [restartedMain] o.s.b.devtools.restart.ChangeableUrls    : The Class-Path manifest attribute in C:\Users\16177\.m2\repository\org\glassfish\jaxb\jaxb-runtime\2.3.2\jaxb-runtime-2.3.2.jar referenced one or more files that do not exist: file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/jakarta.xml.bind-api-2.3.2.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/txw2-2.3.2.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/istack-commons-runtime-3.0.8.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/stax-ex-1.8.1.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/FastInfoset-1.2.16.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/jakarta.activation-api-1.2.1.jar
2020-02-06 16:14:24.646  INFO 15892 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-02-06 16:14:24.647  INFO 15892 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-02-06 16:14:25.845  INFO 15892 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2020-02-06 16:14:25.990  INFO 15892 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 132ms. Found 5 JPA repository interfaces.
2020-02-06 16:14:26.537  INFO 15892 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-02-06 16:14:27.264  INFO 15892 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2020-02-06 16:14:27.274  INFO 15892 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-06 16:14:27.275  INFO 15892 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.30]
2020-02-06 16:14:27.423  INFO 15892 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-06 16:14:27.424  INFO 15892 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 2776 ms
2020-02-06 16:14:27.802  INFO 15892 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2020-02-06 16:14:27.887  INFO 15892 --- [restartedMain] org.hibernate.Version                    : HHH000412: Hibernate Core {5.4.10.Final}
2020-02-06 16:14:28.039  INFO 15892 --- [restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.0.Final}
2020-02-06 16:14:28.179  INFO 15892 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-02-06 16:14:28.350  INFO 15892 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-02-06 16:14:28.376  INFO 15892 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL57Dialect
2020-02-06 16:14:29.602  INFO 15892 --- [restartedMain] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2020-02-06 16:14:29.609  INFO 15892 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-06 16:14:29.710  INFO 15892 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-06 16:14:30.884  WARN 15892 --- [restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2020-02-06 16:14:31.211  INFO 15892 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-02-06 16:14:31.364  INFO 15892 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-02-06 16:14:32.214  INFO 15892 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2020-02-06 16:14:32.218  INFO 15892 --- [restartedMain] com.lhy.blog.BlogApplication             : Started BlogApplication in 8.78 seconds (JVM running for 10.72)
2020-02-06 16:14:40.164  INFO 15892 --- [http-nio-8080-exec-3] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-02-06 16:14:40.278  INFO 15892 --- [http-nio-8080-exec-3] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-02-06 16:14:40.314  INFO 15892 --- [http-nio-8080-exec-3] o.s.web.servlet.DispatcherServlet        : Completed initialization in 34 ms
2020-02-06 16:14:59.379  INFO 15892 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 16:14:59.380  INFO 15892 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 16:14:59.383  INFO 15892 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 16:14:59.392  INFO 15892 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 16:14:59.409  WARN 15892 --- [http-nio-8080-exec-8] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-02-06 16:14:59.417  WARN 15892 --- [http-nio-8080-exec-9] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-02-06 16:14:59.419  INFO 15892 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 16:14:59.420  INFO 15892 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 16:14:59.458  INFO 15892 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 16:14:59.471  INFO 15892 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 16:15:08.509  INFO 15892 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:15:08.533  INFO 15892 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:16:34.517  INFO 15892 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 16:16:34.540  INFO 15892 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 16:19:00.631  INFO 15892 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 16:19:00.647  INFO 15892 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 16:22:55.581  INFO 15892 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:22:55.589  INFO 15892 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:26:22.523  INFO 15892 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:26:22.535  INFO 15892 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:35:21.856  INFO 15892 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 16:35:21.857  INFO 15892 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 16:35:21.860  INFO 15892 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 16:35:21.871  INFO 15892 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:35:21.878  INFO 15892 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 16:35:21.880  INFO 15892 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 16:35:21.894  INFO 15892 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 16:35:21.905  INFO 15892 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:37:38.925  INFO 15892 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 16:37:38.929  INFO 15892 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 16:37:38.950  INFO 15892 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 16:37:38.959  INFO 15892 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 16:37:38.964  INFO 15892 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 16:37:38.967  INFO 15892 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:37:38.977  INFO 15892 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:37:38.980  INFO 15892 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 16:38:05.325  INFO 15892 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:38:05.334  INFO 15892 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:39:03.042  INFO 15892 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 16:39:03.042  INFO 15892 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 16:39:03.042  INFO 15892 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 16:39:03.061  INFO 15892 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 16:39:03.062  INFO 15892 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 16:39:03.068  INFO 15892 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 16:39:03.077  INFO 15892 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:39:03.083  INFO 15892 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:40:25.781  INFO 15892 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 16:40:25.781  INFO 15892 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 16:40:25.797  INFO 15892 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 16:40:25.804  INFO 15892 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 16:40:25.810  INFO 15892 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 16:40:25.827  INFO 15892 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 16:40:25.832  INFO 15892 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:40:25.839  INFO 15892 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:41:05.510  INFO 15892 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:41:05.517  INFO 15892 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:42:44.237  INFO 15892 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 16:42:44.237  INFO 15892 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 16:42:44.238  INFO 15892 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 16:42:44.247  INFO 15892 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 16:42:44.254  INFO 15892 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 16:42:44.260  INFO 15892 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 16:42:44.268  INFO 15892 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:42:44.277  INFO 15892 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:49:28.232  INFO 14116 --- [restartedMain] com.lhy.blog.BlogApplication             : Starting BlogApplication on DESKTOP-KCJEFBA with PID 14116 (E:\CODE\Java\blog\target\classes started by 16177 in E:\CODE\Java\blog)
2020-02-06 16:49:28.239 DEBUG 14116 --- [restartedMain] com.lhy.blog.BlogApplication             : Running with Spring Boot v2.2.4.RELEASE, Spring v5.2.3.RELEASE
2020-02-06 16:49:28.240  INFO 14116 --- [restartedMain] com.lhy.blog.BlogApplication             : The following profiles are active: dev
2020-02-06 16:49:28.400  INFO 14116 --- [restartedMain] o.s.b.devtools.restart.ChangeableUrls    : The Class-Path manifest attribute in C:\Users\16177\.m2\repository\org\glassfish\jaxb\jaxb-runtime\2.3.2\jaxb-runtime-2.3.2.jar referenced one or more files that do not exist: file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/jakarta.xml.bind-api-2.3.2.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/txw2-2.3.2.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/istack-commons-runtime-3.0.8.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/stax-ex-1.8.1.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/FastInfoset-1.2.16.jar,file:/C:/Users/16177/.m2/repository/org/glassfish/jaxb/jaxb-runtime/2.3.2/jakarta.activation-api-1.2.1.jar
2020-02-06 16:49:28.400  INFO 14116 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2020-02-06 16:49:28.400  INFO 14116 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2020-02-06 16:49:31.247  INFO 14116 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2020-02-06 16:49:31.662  INFO 14116 --- [restartedMain] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 398ms. Found 5 JPA repository interfaces.
2020-02-06 16:49:33.536  INFO 14116 --- [restartedMain] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration' of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-02-06 16:49:35.976  INFO 14116 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2020-02-06 16:49:36.018  INFO 14116 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2020-02-06 16:49:36.023  INFO 14116 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.30]
2020-02-06 16:49:36.300  INFO 14116 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2020-02-06 16:49:36.300  INFO 14116 --- [restartedMain] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 7899 ms
2020-02-06 16:49:37.231  INFO 14116 --- [restartedMain] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2020-02-06 16:49:37.445  INFO 14116 --- [restartedMain] org.hibernate.Version                    : HHH000412: Hibernate Core {5.4.10.Final}
2020-02-06 16:49:38.408  INFO 14116 --- [restartedMain] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.0.Final}
2020-02-06 16:49:38.955  INFO 14116 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2020-02-06 16:49:39.804  INFO 14116 --- [restartedMain] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2020-02-06 16:49:39.829  INFO 14116 --- [restartedMain] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.MySQL57Dialect
2020-02-06 16:49:44.046  INFO 14116 --- [restartedMain] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
2020-02-06 16:49:44.064  INFO 14116 --- [restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2020-02-06 16:49:44.308  INFO 14116 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2020-02-06 16:49:46.992  WARN 14116 --- [restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2020-02-06 16:49:47.421  INFO 14116 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2020-02-06 16:49:47.614  INFO 14116 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2020-02-06 16:49:48.732  INFO 14116 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2020-02-06 16:49:48.735  INFO 14116 --- [restartedMain] com.lhy.blog.BlogApplication             : Started BlogApplication in 22.077 seconds (JVM running for 26.435)
2020-02-06 16:49:54.636  INFO 14116 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2020-02-06 16:49:54.636  INFO 14116 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2020-02-06 16:49:54.663  INFO 14116 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 27 ms
2020-02-06 16:49:54.923  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:49:55.630  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:49:59.974  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:49:59.988  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:50:29.940  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:50:29.958  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:51:21.954  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:51:21.961  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:51:22.234  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:51:22.241  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:51:33.487  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 16:51:33.487  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 16:51:33.498  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 16:51:33.508  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:51:33.514  WARN 14116 --- [http-nio-8080-exec-7] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-02-06 16:51:33.514  WARN 14116 --- [http-nio-8080-exec-6] org.hibernate.orm.deprecation            : HHH90000016: Found use of deprecated 'collection property' syntax in HQL/JPQL query [t.blogs.size]; use collection function syntax instead [size(t.blogs)].
2020-02-06 16:51:33.518  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}
2020-02-06 16:51:33.544  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-01 11:14:13.236}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 16:51:33.566  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 16:51:33.612  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 16:51:40.885  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/admire/68/1', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.admire', args=[68, 1]}
2020-02-06 16:51:40.990  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : null
2020-02-06 16:51:54.429  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/admire/68/-1', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.admire', args=[68, -1]}
2020-02-06 16:51:54.445  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : null
2020-02-06 16:51:59.398  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/admire/68/1', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.admire', args=[68, 1]}
2020-02-06 16:51:59.411  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : null
2020-02-06 16:52:07.132  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 16:52:07.140  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 16:52:07.154  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 16:52:07.174  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 16:52:07.176  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:52:07.180  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 16:52:07.187  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:51:59.404}
2020-02-06 16:52:07.194  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:51:59.404}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 16:52:12.304  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/admire/68/1', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.admire', args=[68, 1]}
2020-02-06 16:52:12.321  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : null
2020-02-06 16:53:28.396  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:53:28.403  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 16:54:24.072  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:54:24.079  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 16:54:45.535  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:54:45.545  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 16:55:52.734  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 16:55:52.742  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 17:00:20.576  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:00:20.583  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 17:01:04.083  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:01:04.093  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 17:02:37.744  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:02:37.756  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 17:07:36.634  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:07:36.641  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 17:16:58.474  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:16:58.483  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 17:16:59.015  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:16:59.021  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 17:18:09.790  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:18:09.798  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 17:19:13.269  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:19:13.274  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 17:22:43.093  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:22:43.105  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 17:25:54.841  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 17:25:54.912  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 17:26:56.105  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:26:56.114  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 16:52:12.313}
2020-02-06 17:27:23.999  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/admire/68/1', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.admire', args=[68, 1]}
2020-02-06 17:27:24.020  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : null
2020-02-06 17:28:11.044  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:28:11.052  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}
2020-02-06 17:28:27.234  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:28:27.244  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}
2020-02-06 17:28:39.757  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:28:39.764  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}
2020-02-06 17:28:49.674  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:28:49.680  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}
2020-02-06 17:28:58.302  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:28:58.307  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}
2020-02-06 17:29:04.405  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 17:29:04.412  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}
2020-02-06 17:32:02.072  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 17:32:02.092  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 17:32:38.971  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 12]}
2020-02-06 17:32:38.999  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 17:35:46.444  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 12]}
2020-02-06 17:35:46.458  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 17:35:56.540  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 1]}
2020-02-06 17:35:56.555  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 3 containing com.lhy.blog.po.Blog instances
2020-02-06 17:36:45.104  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 123]}
2020-02-06 17:36:45.116  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 1 containing com.lhy.blog.po.Blog instances
2020-02-06 18:42:00.360  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 1234y54yh]}
2020-02-06 18:42:00.365  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 0 containing UNKNOWN instances
2020-02-06 18:42:47.307  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 1234y54yh]}
2020-02-06 18:42:47.310  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 0 containing UNKNOWN instances
2020-02-06 18:42:47.386  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 1234y54yh]}
2020-02-06 18:42:47.389  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 0 containing UNKNOWN instances
2020-02-06 18:46:38.242  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 1234y54y]}
2020-02-06 18:46:38.246  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 0 containing UNKNOWN instances
2020-02-06 18:46:46.511  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 12]}
2020-02-06 18:46:46.521  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 18:46:52.214  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 123日3]}
2020-02-06 18:46:52.218  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 0 containing UNKNOWN instances
2020-02-06 18:51:43.044  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 123日3]}
2020-02-06 18:51:43.051  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 0 containing UNKNOWN instances
2020-02-06 18:52:02.374  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 18:52:02.376  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 18:52:02.384  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 123日3]}
2020-02-06 18:52:02.390  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 18:52:02.399  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 0 containing UNKNOWN instances
2020-02-06 18:52:02.405  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 18:52:02.409  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 18:52:02.417  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 18:53:46.096  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 12]}
2020-02-06 18:53:46.106  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 18:53:56.745  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 1, size 5, sort: updateTime: DESC], 12]}
2020-02-06 18:53:56.750  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Page 2 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 18:54:10.719  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 18:54:10.724  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 18:54:10.730  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 18:54:10.735  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 18:54:10.732  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 12]}
2020-02-06 18:54:10.741  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}, Blog{id=58, title='Lake Counting——八连通的积水（深度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:12:18.379, updateTime=2020-01-31 19:48:39.358}]
2020-02-06 18:54:10.747  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 18:54:10.753  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 18:54:15.468  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 1, size 5, sort: updateTime: DESC], 12]}
2020-02-06 18:54:15.473  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Page 2 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 18:55:08.862  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 18:55:08.866  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-01-31 19:47:59.597}
2020-02-06 18:57:29.291  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/admire/81/1', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.admire', args=[81, 1]}
2020-02-06 18:57:29.305  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : null
2020-02-06 19:02:52.592  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:02:52.598  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:03:27.602  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:03:27.606  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:04:16.213  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 19:04:16.217  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 19:04:16.228  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 19:04:16.239  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 19:04:16.242  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 19:04:16.243  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:04:16.247  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:04:16.253  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 19:04:51.139  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 19:04:51.139  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 19:04:51.151  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 19:04:51.153  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:04:51.165  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 19:04:51.176  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:04:51.186  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 19:04:51.186  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 19:05:46.189  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:05:46.200  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:05:53.796  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:05:53.803  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:09:11.726  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:09:11.732  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:09:27.322  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:09:27.326  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:12:15.693  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:12:15.699  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:12:16.118  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:12:16.123  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:13:12.511  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:13:12.519  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:13:26.099  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:13:26.106  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:15:31.310  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:15:31.316  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:15:55.344  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:15:55.348  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:18:32.980  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:18:33.334  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:18:33.384  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:18:33.389  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:20:29.906  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:20:29.910  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:21:17.351  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:21:17.355  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:22:12.062  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:22:12.070  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:23:40.049  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:23:40.054  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:25:09.218  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:25:09.222  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:25:18.734  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:25:18.739  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:26:16.559  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:26:16.563  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:29:43.409  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:29:43.414  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:38:38.473  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:38:38.483  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:39:16.179  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:39:16.187  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:56:26.153  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 19:56:26.157  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 19:56:26.158  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 19:56:26.162  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:56:26.179  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 19:56:26.186  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 19:56:26.186  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:56:26.198  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 19:57:00.036  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:57:00.043  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:58:14.493  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 19:58:14.506  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 19:58:14.511  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 19:58:14.514  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 19:58:14.520  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:58:14.524  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 19:58:14.530  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 19:58:14.534  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:58:43.414  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:58:43.419  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 19:58:59.071  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 19:58:59.076  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:00:13.068  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:00:13.080  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:02:04.657  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:02:04.662  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:02:07.336  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:02:07.340  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:02:16.626  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:02:16.631  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:02:19.800  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:02:19.804  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:02:27.686  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:02:27.692  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:03:36.486  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:03:36.492  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:05:24.319  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:05:24.324  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:06:08.098  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:06:08.103  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:07:02.540  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:07:02.547  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:15:54.460  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:15:54.474  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:15:54.475  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:15:54.479  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:15:54.485  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:15:54.493  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:15:54.493  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:15:54.497  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:16:00.066  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:16:00.067  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:16:00.066  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:16:00.081  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:16:00.081  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:16:00.069  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:16:00.090  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:16:00.092  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:16:53.975  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:16:53.984  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:16:53.986  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:16:53.999  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:16:54.003  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:16:54.003  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:16:54.007  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:16:54.018  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:18:36.735  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:18:36.741  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:18:36.748  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:18:36.752  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:18:36.756  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:18:36.759  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:18:36.763  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:18:36.766  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:22:43.414  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:22:43.414  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:22:43.417  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:22:43.431  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:22:43.436  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:22:43.442  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:22:43.448  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:22:43.452  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:40:37.529  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:40:37.543  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:40:37.547  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:40:37.547  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:40:37.554  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:40:37.557  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:40:37.561  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:40:37.569  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:41:10.318  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:41:10.321  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:41:10.322  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:41:10.330  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:41:10.331  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:41:10.351  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 20:41:10.379  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 20:41:10.383  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:41:18.120  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 12]}
2020-02-06 20:41:18.134  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 20:41:23.158  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:41:23.165  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:41:23.167  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 12]}
2020-02-06 20:41:23.171  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:41:23.172  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:41:23.177  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:41:23.179  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 20:41:23.195  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:41:38.258  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:41:38.259  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 12]}
2020-02-06 20:41:38.272  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:41:38.274  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 20:41:38.276  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:41:38.281  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:41:38.295  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:41:38.299  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:41:51.022  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 123日3]}
2020-02-06 20:41:51.025  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 0 containing UNKNOWN instances
2020-02-06 20:41:55.702  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:41:55.709  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:41:55.712  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:41:55.712  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:41:55.718  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:41:55.724  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:41:55.740  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 20:41:55.756  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 20:44:09.221  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:44:09.222  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:44:09.226  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:44:09.230  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:44:09.235  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:44:09.235  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:44:09.242  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 20:44:09.253  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 20:53:55.113  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:53:55.123  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:53:55.128  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:53:55.135  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:53:55.139  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 20:53:55.144  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:53:55.145  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:53:55.159  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 20:55:13.741  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 20:55:13.741  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 20:55:13.753  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 20:55:13.756  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 20:55:13.763  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 20:55:13.765  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 20:55:13.782  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 20:55:13.794  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:03:02.109  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 21:03:02.110  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 21:03:02.126  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 21:03:02.132  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 21:03:02.145  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 21:03:02.148  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 21:03:02.151  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 21:03:02.156  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:16:10.103  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 21:16:10.114  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:19:49.142  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 21:19:49.148  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 21:19:49.156  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 21:19:49.181  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 21:19:49.192  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 21:19:49.197  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 21:19:49.198  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 21:19:49.206  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:21:35.339  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/67', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[67]}
2020-02-06 21:21:35.343  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=67, title='表达式求值', content='表达式求值是程序设计编译中的一个最基本的问题，他的实现是栈应用的一个典型范例：

表达式中包含的运算符有`（，），+，-，*，/`，共七种运算符，我们首先要确定这七种运算符的优先级，显然`()`的优先级最高，`*,/`次之，`+,-`的优先级最低，那么`(`与`)`、`+`与`+`、`-`与`-`$$\cdots$$，这些优先级又怎么区分呢？我么用栈求表达式值时是将运算符存在栈中，例如当前栈中有`+`，当再来`+,-`时，显然栈中的`+`可以出栈了，那么栈中`+`的优先级就高于栈外的`+,-`，因此优先级相同的运算符在栈内的优先级应该高于栈外的优先级。下面以表格的形式给出各运算符的优先级：

| 操作符 | # | ( | *,/| +,- | ) |
| :-: | :-: | :-: | :-: | :-: | :-: |
| isp | 0 | 1 | 5 | 3 | 6 |
| icp | 0 | 6 | 4 | 2 | 1 |


其中引入`#`是为了统一运算。
对应的计算优先级的函数如下：

```cpp
int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}
```
这里介绍两种表达式求值的思路：
###### 1. 直接求值法
直接法顾名思义就是直接计算，不需要事先处理表达式；该方法需要两个栈，栈`nsta`存数字，栈`osta`存运算符，一次遍历表达式字符串，这会出现一下几种操作：
1. 当前字符是数字时，直接压入`nsta`；
2. 当前字符是运算符时:
	1. `isp(osta.top) < icp(ch)`，`ch`直接入栈；
	2. `isp(osta.top) > icp(ch)`，`osta.top`出栈，运算结果压入`nsta`，重复步骤1；
	3. `isp(osta.top) == icp(ch)`，只有两种可能，`isp('(') == icp(')')`，`isp('#') == icp('#')`，第一种情况左括号出栈，第二种情况表达式计算结束。

对应直接的直接发代码如下：

```cpp
void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;	//注意顺序
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;	//继续比较osta中的下一个运算符
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());	//nsta中只有一个元素，即为最终结果
}
```
###### 2. 后缀表达式求值
我们的表达式其实是中缀表达式，若将中缀表达式转化为后缀表达式，则只需直接计算即可，不需要考虑优先级的问题，因此将中缀表达式转化为后缀表达式的过程就是按优先级排列运算符，
其中将中缀表达式转化为后缀表达式的代码如下：

```cpp
queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}
```

 这里将后缀表达式存在队列中，同样也可以存在数组中，最后直接计算的代码如下：
 

```cpp
void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

```
最终完整的代码如下：

```cpp
#include <stdio.h>
#include <iostream>
#include <stack>
#include <queue>
#include <cstring>
using namespace std;

int Isp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 1; break;
        case '*': k = 5; break;
        case '/': k = 5; break;
        case '+': k = 3; break;
        case '-': k = 3; break;
        case ')': k = 6; break;
    }
    return k;
}

int Icp(char ch){
    int k;
    switch(ch){
        case '#': k = 0; break;
        case '(': k = 6; break;
        case '*': k = 4; break;
        case '/': k = 4; break;
        case '+': k = 2; break;
        case '-': k = 2; break;
        case ')': k = 1; break;
        default: k = -1;
    }
    return k;
}

queue<char> getSuffix(char str[]){
    stack<char> sta;
    queue<char> que;
    int len = strlen(str);
    str[len++] = '#';
    sta.push('#');
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = sta.top();
        if(Icp(tmp1) < 0)
            que.push(tmp1);
        else if(Isp(tmp2) < Icp(tmp1))
            sta.push(tmp1);
        else if(Isp(tmp2) > Icp(tmp1)){
            que.push(tmp2);
            sta.pop();
            i--;
        }
        else
            sta.pop();
    }
    queue<char> que1 = que;
    printf("转化为后缀表达式如下：");
    while(!que1.empty()){
        printf("%c", que1.front());
        que1.pop();
    }
    printf("\n");
    return que;
}

void calcSuffix(queue<char> que){
    stack<int> exp;
    int a, b;
    while(!que.empty()){
        if(que.front() >= '0' && que.front() <= '9')
            exp.push(que.front()-'0');
        else{
            a = exp.top();
            exp.pop();
            b = exp.top();
            exp.pop();
            switch(que.front()){
                case '+': exp.push(a+b); break;
                case '-': exp.push(b-a); break;
                case '*': exp.push(a*b); break;
                case '/': exp.push(b/a); break;
            }
        }
        que.pop();
    }
    printf("通过后缀表达式计算结果为: %d\n", exp.top());
}

void directCalc(char str[]){
    stack<int> nsta;    //运算数栈
    stack<char> osta;   //运算符栈
    int len = strlen(str);
    str[len++] = '#';
    osta.push('#');
    int a, b;
    for(int i=0; i<len; i++){
        char tmp1 = str[i];
        char tmp2 = osta.top();
        if(tmp1 >= '0' && tmp2 <= '9')
            nsta.push(tmp1-'0');
        else{
            if(Isp(tmp2) < Icp(tmp1))
                osta.push(tmp1);
            else if(Isp(tmp2) == Icp(tmp1))
                osta.pop();
            else{
                a = nsta.top();
                nsta.pop();
                b = nsta.top();
                nsta.pop();
                switch(osta.top()){
                    case '+': nsta.push(a+b); break;
                    case '-': nsta.push(b-a); break;
                    case '*': nsta.push(a*b); break;
                    case '/': nsta.push(b/a); break;
                }
                osta.pop();
                i--;
            }
        }
    }
    printf("直接计算结果：%d\n", nsta.top());
}
//  a+b-a*((c+d)/e-f)+g
int main(){
    char str[100];
    queue<char> que;
    scanf("%s", str);
    // 转化为后缀表达式，再通过后缀表达式计算结果
//    que = getSuffix(str);
//    calcSuffix(que);
    // 直接计算
    directCalc(str);
    return 0;
}

```
', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}
2020-02-06 21:22:12.273  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 21:22:12.286  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:22:17.949  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 21:22:17.955  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 18:57:29.297}
2020-02-06 21:23:15.250  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/admire/81/1', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.admire', args=[81, 1]}
2020-02-06 21:23:15.262  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : null
2020-02-06 21:28:57.448  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 21:28:57.452  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 21:23:15.256}
2020-02-06 21:33:25.599  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 21:33:25.602  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 21:23:15.256}
2020-02-06 21:33:50.779  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 21:33:50.782  INFO 14116 --- [http-nio-8080-exec-4] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 21:23:15.256}
2020-02-06 21:34:29.631  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 21:34:29.635  INFO 14116 --- [http-nio-8080-exec-2] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 21:23:15.256}
2020-02-06 21:35:03.999  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 21:35:04.004  INFO 14116 --- [http-nio-8080-exec-6] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 21:23:15.256}
2020-02-06 21:35:39.635  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 21:35:39.639  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 21:23:15.256}
2020-02-06 21:36:18.140  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 21:36:18.149  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:36:22.234  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 12]}
2020-02-06 21:36:22.245  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:37:20.204  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 21:37:20.217  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:37:24.049  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 12]}
2020-02-06 21:37:24.057  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:38:46.568  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/search', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.search', args=[Page request [number: 0, size 5, sort: updateTime: DESC], 12]}
2020-02-06 21:38:46.574  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:39:43.217  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 21:39:43.228  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:45:36.960  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/typesIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.typesIndex', args=[]}
2020-02-06 21:45:36.960  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/tagsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.tagIndex', args=[]}
2020-02-06 21:45:36.970  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/newBlogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.newBlogsIndex', args=[]}
2020-02-06 21:45:36.980  INFO 14116 --- [http-nio-8080-exec-10] com.lhy.blog.aspect.LogAspect            : Result : [Type{id=46, name='PAT（乙级）'}, Type{id=45, name='挑战程序设计竞赛'}, Type{id=47, name='数据结构'}, Type{id=62, name='前端'}, Type{id=48, name='填坑笔记'}, Type{id=88, name='算法'}]
2020-02-06 21:45:36.987  INFO 14116 --- [http-nio-8080-exec-7] com.lhy.blog.aspect.LogAspect            : Result : [Blog{id=81, title='1030 完美数列 (25 分)', content='null', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 21:23:15.256}, Blog{id=68, title='归并排序（分治法）', content='null', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}, Blog{id=132, title='123', content='null', firstPicture='https://picsum.photos/id/1027/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-02-04 14:40:08.158, updateTime=2020-02-04 14:43:27.58}, Blog{id=67, title='表达式求值', content='null', firstPicture='https://picsum.photos/id/104/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:24:34.909, updateTime=2020-02-01 11:13:56.093}, Blog{id=57, title='迷宫的最短路径（宽度优先搜索）', content='null', firstPicture='https://picsum.photos/id/1026/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 12:26:49.477, updateTime=2020-02-01 11:13:28.719}, Blog{id=64, title='css实现百叶窗照片墙', content='null', firstPicture='https://picsum.photos/id/1037/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:22:54.544, updateTime=2020-02-01 11:13:10.148}, Blog{id=60, title='1035 插入与归并 (25 分)', content='null', firstPicture='https://picsum.photos/id/1032/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:18:56.497, updateTime=2020-01-31 19:52:21.598}, Blog{id=59, title='KMP算法（我的理解）', content='null', firstPicture='https://picsum.photos/id/1035/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-07 18:16:01.463, updateTime=2020-01-31 19:49:19.653}]
2020-02-06 21:45:36.988  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 21:45:36.992  INFO 14116 --- [http-nio-8080-exec-1] com.lhy.blog.aspect.LogAspect            : Result : [Tag{id=34, name='C++'}, Tag{id=39, name='HTML'}, Tag{id=40, name='CSS'}, Tag{id=41, name='JavaScript'}, Tag{id=35, name='Java'}, Tag{id=36, name='Python'}, Tag{id=37, name='Spring Boot'}, Tag{id=38, name='Redis'}, Tag{id=42, name='Vue.js'}, Tag{id=43, name='Mysql'}]
2020-02-06 21:45:36.996  INFO 14116 --- [http-nio-8080-exec-5] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:45:45.098  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/68', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[68]}
2020-02-06 21:45:45.101  INFO 14116 --- [http-nio-8080-exec-8] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=68, title='归并排序（分治法）', content='归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略，分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之。归并排序的时间复杂度为$$O(n\log_2n)$$。

下面用一张图了解用分治法实现归并排序的过程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705102749236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
可以看到，我们将原序列不断进行二分，直至只有一个元素，得到$$n$$个只含有一个元素的序列，再将这$$n$$个需序列不断地两两合并，最终得到一个有序的序列。

这个过程中，合并是实现排序的关键过程，我们是这样实现合并相邻子序列的：

我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705105338282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
这个过程很简单，只要比较两个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可，合并的代码如下：
```cpp
void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}
```
这里用到了辅助数组`temp[]`暂存合并生成的序列，合并完毕后再通过`temp[]`修改，其中`[left, mid]`表示第一个序列，`[mid+1, right]`表示第二个序列。

以下给出递归实现的完整码：
```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int left, int right){
    if(left == right)
        return;
    int mid = (left + right)/2;
    MergeSort(arr, left, mid);				//二分
    MergeSort(arr, mid+1, right);			//二分
    MergeSortArr(arr, left, mid, right);	//归并
    for(int i=0; i<10; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 0, 9);
}
```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190705121050166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
归并排序也可以用非递归实现，实现的过程与递归有所不同，不同之处就在于“分”的阶段，从以上递归思路中可以发现，“分”的最终结果是将`n`为数组分成`n`组，即每组只包含一个元素，那么这一过程是不是可以省略呢？答案是可以的，非递归就可以略掉这一过程；

非递归实现的函数如下：

```cpp
void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;//这里的mid不能等于(left+right)/2，具体原因可仔细模拟这一过程
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}
```

以下给出非递归实现的完整代码：

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

void MergeSortArr(int arr[], int left, int mid, int right){
    int temp[right-left+1];
    int i = left, j = mid + 1, k = 0;
    while(i <= mid && j <= right){
        if(arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while(i <= mid)
        temp[k++] = arr[i++];
    while(j <= right)
        temp[k++] = arr[j++];
    for(int i=0; i<k; i++)
        arr[left+i] = temp[i];
}

void MergeSort(int arr[], int n){
    int left, mid, right;
    for(int i=2; ; i*=2){   //这里循环结束条件放到了最后，因为当i>n时还要进行一次排序
        for(int j=0; j<n; j+=i){
            left = j;
            mid = (2*j+i-1)/2 < n ? (2*j+i-1)/2:n-1;
            right = (j+i-1) < n ? j+i-1 : n-1;
            MergeSortArr(arr, left, mid, right);
        }
        for(int k=0; k<n; k++){
            printf("%d ", arr[k]);
        }
        printf("\n");
        if(i > n)
            break;
    }
}

int main(){
    int arr[10] = {3, 1, 2, 8, 7, 5, 9, 4, 0, 6};
    MergeSort(arr, 10);
}

```
输出结果如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717084218838.png)
可以仔细对比两种方法的输出结果，生成的中间序列是有区别的。', firstPicture='https://picsum.photos/id/1043/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 10:58:37.837, updateTime=2020-02-06 17:27:24.012}
2020-02-06 21:45:46.981  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blogsIndex', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blogsIndex', args=[Page request [number: 0, size 6, sort: updateTime: DESC]]}
2020-02-06 21:45:46.987  INFO 14116 --- [http-nio-8080-exec-3] com.lhy.blog.aspect.LogAspect            : Result : Page 1 of 2 containing com.lhy.blog.po.Blog instances
2020-02-06 21:46:02.109  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Request : Request{url='http://localhost:8080/blog/81', ip='127.0.0.1', classMethod='com.lhy.blog.web.IndexController.blog', args=[81]}
2020-02-06 21:46:02.116  INFO 14116 --- [http-nio-8080-exec-9] com.lhy.blog.aspect.LogAspect            : Result : Blog{id=81, title='1030 完美数列 (25 分)', content='#### 题目
给定一个正整数数列，和正整数$$p$$，设这个数列中的最大值是$$M$$，最小值是$$m$$，如果 $$M\le mp$$，则称这个数列是完美数列。

现在给定参数$$p$$和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
#### 输入格式
输入第一行给出两个正整数`N`和`p`，其中$$N(\le10^5)$$是输入的正整数的个数，$$p(\le10^9)$$是给定的参数。第二行给出 `N`个正整数，每个数不超$$10^9$$。
#### 输出格式
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
#### 输入样例
>10 8
2 3 20 4 5 1 6 7 8 9

#### 输出样例
>8

#### 分析
1. 首先应该想到的是给个数列排序，从到到小排序，可以用`sort()`函数实现，但我为了加深对快排的理解，手写的快排。
2. 一开始的思路，最大值`arr[n-1]`固定，然后用`arr[min]*p`依次与`arr[n-1]`比较，直到满足条件，这个逻辑是不严谨的，因为这样得到的个数不一定是最大的，例如序列$1, 2, 3, 4, 5, 6, 7, 8, 8, 20$，`p = 8`，按此方法得到`ans=8`，而实际最大值为9。
3. 尽然最大值也不固定，那么可以采用两个`left,right`，分别表示最小值下标和最大值下标，然后依次向中间靠拢，此时的策略是当`arr[right] > arr[left]`时，可以`compare(arr[left+1],arr[right])`或者`compare(arr[left],arr[right-1])`，由此想到用递归，提交发现有一个测试点超时。
4. 于是继续改进，放弃递归，定义两层`for()`循环，外层`(i=0; i<n; i++)`遍历，内层`(j=i+1; j<n; j++)`遍历，即每确定一个最小值，就在之后寻找满足条件的数。这个算法还可以优化，因为我们有`ans`来计数最大个数，所以当`i<j<i+ans`时，完全没必要考虑，所以可以优化为`for(j=i+ans; j<n; j++)`，那么外层循环能不能优化呢，当然能，我们发现当`n-i <= ans`时，此时后面满足条件的数以不可能大于`ans`，也可以不考虑，所以外层循环为`for(i=0; i<n-ans; i++)`。
#### 代码

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;

const int MaxSize = 100000;

void Quick_sort(int arr[], int left, int right){
    if(left > right)
        return;
    int i=left, j=right;
    int tmp = arr[left];
    while(i != j){
        while(arr[j] >= tmp && j > i)
            j--;
        while(arr[i] <= tmp && j > i)
            i++;
        if(i != j){
            int t = arr[i];
            arr[i] = arr[j];
            arr[j] = t;
        }
    }
    arr[left] = arr[i];
    arr[i] = tmp;
    Quick_sort(arr, left, j-1);
    Quick_sort(arr, i+1, right);
}

int main(){
    int n, p;
    int arr[MaxSize];
    scanf("%d%d", &n, &p);
    for(int i=0; i<n; i++)
        scanf("%d", arr+i);
    Quick_sort(arr, 0, n-1);

    int ans = 1;
    for(int i=0; i<n-ans; i++){
        long long tmp = (long long)arr[i]*p;	//这里的强制类型转换必须要加
        for(int j=i+ans; j<n; j++){
            if(arr[j] > tmp)
                break;
            if(j-i+1 > ans)
                ans = j-i+1;
        }
    }
    printf("%d\n", ans);
    return 0;
}

```
#### 提交结果
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019070212490222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwOTQxNzIy,size_16,color_FFFFFF,t_70)
', firstPicture='https://picsum.photos/id/1055/900/600', flag='原创', views=0, appreciation=true, shareStatement=true, commentabled=true, published=true, recommend=true, createTime=2020-01-08 14:38:16.986, updateTime=2020-02-06 21:23:15.256}
